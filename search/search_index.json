{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hashgraph Online","text":"<p>Hashgraph Online represents a paradigm shift in online interactions, as envisioned by the Hashgraph Consensus Standards working group. This innovative framework reimagines the concept of being \"online\" in the context of decentralized applications. Moving away from traditional reliance on centralized infrastructures such as AWS or GCP, Hashgraph Online facilitates direct peer-to-peer connectivity. Utilizing the Hedera Consensus Service, this document outlines standards that enable peers to engage in online activities - reading, interacting, and existing in a network - without the intermediation of conventional cloud services. This approach heralds a new era of decentralized online experiences, fostering greater autonomy and interconnectedness among users.</p> <p>All standards and ideas presented in this document are to be considered in alpha development and subject to change. Implementation of these standards remains at your own risk during this phase of the launch.</p>"},{"location":"definitions/","title":"Definitions","text":""},{"location":"definitions/#definitions","title":"Definitions","text":"<p>A formal set of definitions used within the Hashgraph Consensus Standards Improvement proposals. These are NOT standards and should be used for reference only.</p>"},{"location":"definitions/#spheres","title":"Spheres","text":"<ul> <li>Spheres are the HCS equivalent of DNS. Every Sphere is a Topic ID which includes the current records.</li> <li>Messages written to a Sphere are NOT valid unless the payer_account_id owns the matching .\u210f domain from https://kabuto.sh</li> </ul>"},{"location":"definitions/#resource-conceptual-addresses","title":"Resource (Conceptual Addresses)","text":"<ul> <li>A resource is any piece of data on Hedera that is referenced by an entity id on Hedera / Hashgraphs. Valid entities are Topic IDs.</li> </ul>"},{"location":"definitions/#hashgraph-resource-locator","title":"Hashgraph Resource Locator","text":"<p>The protocol for finding data inscribed on the Hedera Consensus Service, following the Hashgraph Consensus Standards.</p> <ul> <li>an HRL locates a resource. The format for an HRL is as follows. A formal future HCS will cover all cases for HRLs.</li> <li><code>hcs://{protocol_standard}/{resource_id}</code></li> <li><code>protocol_number</code> should always be a valid HCS standard, eg <code>1</code></li> <li><code>resource_id</code> should always be a valid Resource</li> <li>A valid example of an HRL is: <code>hcs://1/0.0.123456</code></li> </ul>"},{"location":"definitions/#public-registries","title":"Public Registries","text":"<p>Topic Ids which are managed by the community for the convenience of the ecosystem. These topics are public and not managed by a specific entity. Proceed with caution when consuming data inscribed on these topics.</p>"},{"location":"definitions/#guarded-registries","title":"Guarded Registries","text":"<p>Topic Ids which are managed by the HCS Council for the convenience of the ecosystem. These topics should be private topics to ensure proper validation of messages. HCS will cover this idea in detail.</p>"},{"location":"definitions/#hashsite","title":"Hashsite","text":"<p>A fully rendered decentralized application, composed of valid HTML Markup, JavaScript, and CSS which is inscribed following HCS standards.</p>"},{"location":"definitions/#hashgraph-package-management-hpm","title":"Hashgraph Package Management (HPM)","text":"<ul> <li>A registry of pointers to various scripts that clients can download to create Hashsites.</li> <li>The registry will be browsable on hpm.h</li> <li>HPMs can be installed through inscriptions reference to develop Hashsites eg <code>&lt;script src=\u201dhpm.h/date-fns\u201d /&gt;</code></li> </ul>"},{"location":"tooling/","title":"Tooling","text":"<p>Welcome to the HCS Community Tools page! Here, we showcase innovative tools developed by the community for enhancing your experience with various HCS Protocols. These tools offer a range of functionalities from analytics to API support, designed to enrich your interaction with HCS.</p>"},{"location":"tooling/#tools-list","title":"Tools List","text":""},{"location":"tooling/#tierbot-inscription-tools","title":"Tierbot Inscription Tools","text":"<ul> <li>Description: A web interface to easily inscribe valid HCS-1 Files and Hashinals on Hedera.</li> <li>Link: https://tier.bot/inscribe</li> <li>Highlight: Twitter Highlight </li> </ul>"},{"location":"tooling/#turtlemoon-inscription-tools","title":"Turtlemoon Inscription Tools","text":"<ul> <li>Description: A downloadable client to easily inscribe valid HCS-1 Files and Hashinals on Hedera.</li> <li>Link: Download Link</li> <li>Highlight: Twitter Highlight </li> </ul>"},{"location":"tooling/#hashinals-inscription-portal","title":"Hashinals Inscription Portal","text":"<ul> <li>Description: A web interface to easily find inscription numbers.</li> <li>Link: https://www.hashinals.com</li> <li>Highlight: Twitter Highlight </li> </ul>"},{"location":"tooling/#tierbot-analytics","title":"Tierbot Analytics","text":"<ul> <li>Description: Advanced analytics for HCS20. Explore balances, transactions, holder number amounts, and more.</li> <li>Link: Analytics Overview</li> <li>Highlight: Twitter Highlight </li> </ul>"},{"location":"tooling/#trustenterprise-api","title":"TrustEnterprise API","text":"<ul> <li>Description: An API for HCS20 inscriptions, offering a robust way to interact with HCS20 on Hedera.</li> <li>Link: API Pull Request</li> <li>Highlight: Twitter Highlight</li> </ul> <p>These tools represent the vibrant creativity and dedication of our community. Dive in and explore the potential of HCS20 through these innovative applications!</p>"},{"location":"standards/hcs-1/","title":"HCS-1 Standard: File Data Management with Hedera Consensus Service","text":""},{"location":"standards/hcs-1/#status-published","title":"Status: Published","text":""},{"location":"standards/hcs-1/#table-of-contents","title":"Table of Contents","text":"<ul> <li>HCS-1 Standard: File Data Management with Hedera Consensus Service<ul> <li>Status: Published</li> <li>Table of Contents</li> </ul> </li> <li>Authors</li> <li>Abstract</li> <li>Motivation</li> <li>HCS Topic Validation<ul> <li>Memo Structure</li> </ul> </li> <li>Encoding and Chunking<ul> <li>Uploading to HCS</li> </ul> </li> <li>Retrieving and Reassembling</li> <li>Conclusion</li> </ul>"},{"location":"standards/hcs-1/#authors","title":"Authors","text":"<ul> <li>Kantorcodes https://twitter.com/kantorcodes</li> </ul>"},{"location":"standards/hcs-1/#additional-authors","title":"Additional Authors","text":"<ul> <li>Patches https://twitter.com/tmcc_patches</li> </ul>"},{"location":"standards/hcs-1/#abstract","title":"Abstract","text":"<p>The HCS-1 standard provides a systematic approach to encode, chunk, upload, retrieve, and reassemble file data for applications using Hedera Consensus Service (HCS). This process is agnostic of the implementation details, focusing on the JSON structure and the use of a Topic ID for efficient data management.</p>"},{"location":"standards/hcs-1/#motivation","title":"Motivation","text":"<p>Storing data on-chain has become increasingly important for verification, immutability, and scale of web3 applications. This specification will enable future use cases like Hashinals, truly decentralized applications, and enhanced peer-to-peer communication without the need of typical cloud infrastructure.</p>"},{"location":"standards/hcs-1/#hcs-topic-validation","title":"HCS Topic Validation","text":"<p>HCS-1 topics must</p> <ul> <li>include a SHA-256 hash of the file being uploaded, the compression algorithm being used, and the encoding as the memo. Viewers of HCS-1 data will read the memo to understand if the file data is valid by comparing the file hash to the memo. Please read Memo Structure for details on how to properly generate a memo.</li> <li>include a Submit Key. HCS-1 Topics without a Submit Key will automatically be marked as invalid files, and will be ignored.</li> <li>NOT include an Admin Key. HCS-1 Topics with an Admin Key will automatically be marked as invalid files, and will be ignored. This ensures that data cannot be deleted, reducing risk for all participants in the protocol. In summary, a valid HCS-1 Topic includes a SHA-256 hash of the file being uploaded in its memo, a submit key, and no admin key.</li> </ul>"},{"location":"standards/hcs-1/#memo-structure","title":"Memo Structure","text":"<p>The format for the memo is as follows:</p> <p><code>[hash]:[algo]:[encoding]</code></p> <ul> <li>[hash] is the SHA-256 hash of the file being uploaded before any compression</li> <li>[algo] is the compression algorithm being used, for example, <code>zstd</code></li> <li>[encoding] is the encoding used to store the compressed file</li> </ul> <p>For example a valid memo would like:</p> <p><code>532eaabd9574880dbf76b9b8cc00832c20a6ec113d682299550d7a6e0f345e25:zstd:base64</code></p> <p>At this time, only zstd and base64 encoding are supported. If you'd like a different compression algorithm or encoding to be approved, please raise a pull request.</p>"},{"location":"standards/hcs-1/#encoding-and-chunking","title":"Encoding and Chunking","text":"<p>Before uploading to HCS, file data must be formatted correctly by following these three steps</p> <ol> <li>The entire file should be compressed using zstd, this ensures cost-savings on all ends of the protocol in a lossless format.</li> <li>Plenty of implementations for zSTD exist, for example, using NodeJS you could use the MongoDB library: https://github.com/mongodb-js/zstd/tree/main</li> <li><code>const compressedFile = await compress(file, 10);</code></li> <li>We recommend using a compression level of 10, but any compression level should work.</li> <li>After compressing, the resulting data (typically a buffer) should be converted into a base64 string</li> <li> <p>The final base64 string should chunked into segments no greater than 1024 bytes. Each chunk is encapsulated in a JSON object with two attributes:</p> </li> <li> <p><code>o</code>: The order index indicating the chunk's sequence in the overall file.</p> </li> <li><code>c</code>: The chunk's content, a substring of the base64-encoded file. The first chunk aka, <code>o = 0</code> should include a data prefix for the mime type.</li> </ol> <p>The format for the data prefix is <code>data:[mimeType];base64</code> For example: <code>data:image/png;base64,</code></p> <p>The format for each chunk in a message is as follows:</p> <pre><code>{\n  \"o\": 0,\n  \"c\": \"base64-encoded-chunk\"\n}\n</code></pre>"},{"location":"standards/hcs-1/#uploading-to-hcs","title":"Uploading to HCS","text":"<p>Each chunk is uploaded to a Hedera Consensus Service topic as an HCS message. Keep in mind that because of the <code>o</code> property in the JSON schema, the sequence number that the chunk is uploaded in does not matter. This enables uploading many chunks in parallel.</p>"},{"location":"standards/hcs-1/#retrieving-and-reassembling","title":"Retrieving and Reassembling","text":"<p>To display the data, the application retrieves all chunk messages from the specified HCS topic. Chunks are sorted by their order index (<code>o</code>) and concatenated based on their content (<code>c</code>). The combined base64 string is then decoded back into binary data for display.</p> <p>The complete steps are:</p> <ol> <li>Fetch all messages from the Topic ID, and sort them by their index <code>o</code></li> <li>Concatenate the messages together, and decompress the file using a <code>zstd</code> decoding library.</li> <li>Ensure the memo of the Topic ID matches the SHA-256 hash of the decompressed file data.</li> <li>Convert the uncompressed base64 string into binary data</li> </ol>"},{"location":"standards/hcs-1/#conclusion","title":"Conclusion","text":"<p>The HCS-1 standard outlines a robust protocol for managing file data sets of all sizes and mime types within the Hedera Consensus Service, leveraging JSON for data structuring and a registry for efficient topic management. This approach ensures data integrity, facilitates easy data retrieval, and supports scalable application development on Hedera.</p>"},{"location":"standards/hcs-2/","title":"HCS-2 Standard: Advanced Topic Registries","text":""},{"location":"standards/hcs-2/#status-published","title":"Status: Published","text":""},{"location":"standards/hcs-2/#table-of-contents","title":"Table of Contents","text":"<ul> <li>HCS-2 Standard: Advanced Topic Registries<ul> <li>Status: Published</li> <li>Table of Contents</li> </ul> </li> <li>Authors<ul> <li>Primary Author</li> <li>Additional Authors</li> </ul> </li> <li>Abstract</li> <li>Motivation</li> <li>Specification<ul> <li>Registry Format and Usage</li> <li>Operations</li> <li>Register</li> <li>Delete</li> <li>Update</li> <li>Migrate</li> <li>Retrieval</li> <li>Memo for Indexers and Browsers</li> <li>Example Memo Format</li> <li>Indexed Registry Mechanics [enum: 0]</li> <li>Non-Indexed Registry Mechanics [enum: 1]</li> </ul> </li> <li>TTL Use Cases<ul> <li>Use Cases and Functionalities</li> <li>Example URI Format</li> </ul> </li> <li>Validation<ul> <li>Attributes Validation</li> <li>Conclusion</li> </ul> </li> </ul>"},{"location":"standards/hcs-2/#authors","title":"Authors","text":""},{"location":"standards/hcs-2/#primary-author","title":"Primary Author","text":"<ul> <li>Patches https://twitter.com/TMCC_Patches</li> </ul>"},{"location":"standards/hcs-2/#additional-authors","title":"Additional Authors","text":"<ul> <li>Kantorcodes https://twitter.com/kantorcodes</li> </ul>"},{"location":"standards/hcs-2/#abstract","title":"Abstract","text":"<p>This standard introduces advanced methodologies for managing and interacting with Topic Registries within the HCS framework. It focuses on enabling dynamic metadata, versioning, and comprehensive file management through unique identifiers and protocols.</p>"},{"location":"standards/hcs-2/#motivation","title":"Motivation","text":"<p>The advent of dynamic metadata and the need for detailed version histories and state management in decentralized environments have necessitated the development of more sophisticated Topic Registries. This standard aims to provide a robust framework for indexing, retrieving, and interpreting diverse data types, enhancing the utility and scalability of NFTs, and facilitating advanced web functionalities like full site recursion.</p>"},{"location":"standards/hcs-2/#specification","title":"Specification","text":""},{"location":"standards/hcs-2/#registry-format-and-usage","title":"Registry Format and Usage","text":"<p>The registry should adopt a standardized format to ensure consistent access and interpretation. The following fields are introduced:</p> Field Description Example Value <code>p</code> Protocol used by the registry, typically <code>hcs-2</code> for this standard. <code>hcs-2</code> <code>op</code> Operation being executed (register, delete, update). <code>register</code> <code>t_id</code> Topic ID where the registry information is stored. <code>0.0.1234567</code> <code>uid</code> Sequence number for files or states within the registry. <code>42</code> <code>m</code> Optional metadata providing additional context. <code>Update for Q2 release</code> <p><code>m</code> - memo is restricted to 500 characters</p>"},{"location":"standards/hcs-2/#operations","title":"Operations","text":"<p>A list of all operations available for this standard. Note, operations that are not finalized should not be used in production applications.</p> Operation Description Usable in non-indexed topic Finalized <code>Register</code> Adds new entries or versions to the registry. \u2705 \u2705 <code>Migrate</code> Moves messages to a new Topic ID. Previous messages are archived and new state is computed from the new Topic. The new Topic should either replicate all the data, or create a snapshot with a pointer to the old Topic. \u2705 \u274c <code>Delete</code> Removes entries based on UID. \u274c \u2705 <code>Update</code> Modifies existing entries, by changing the referenced sequence number and updating the t_id and metadata pointers. \u274c \u2705"},{"location":"standards/hcs-2/#register","title":"Register","text":"<p>Registration allows creating additional entries / versions to the Topic. Utilize the follow JSON structure for valid messages.</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"register\",\n  \"t_id\": \"TOPIC_ID_TO_REGISTER\",\n  \"metadata\": \"OPTIONAL_METADATA (HIP-412 compliant)\",\n  \"m\": \"OPTIONAL_MEMO\",\n}\n</code></pre> <p>example useage:</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"register\",\n  \"t_id\": \"0.0.123456\",\n  \"metadata\": \"hcs://1/0.0.456789\",\n  \"m\": \"register t\",\n}\n</code></pre>"},{"location":"standards/hcs-2/#delete","title":"Delete","text":"<p>Remove entries based on UID or sequence number of the message on the topic id.</p> <p>This operation is invalid for non-indexed topics</p> <p>Use the following JSON structure:</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"delete\",\n  \"uid\": \"SEQUENCE_NUMBER_OF_REGISTER_MESSAGE_TO_DELETE\",\n  \"m\": \"OPTIONAL_MEMO\"\n}\n</code></pre> <p>example usage:</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"delete\",\n  \"uid\": \"33\",\n  \"m\": \"remove hashsite from users bookmark\"\n}\n</code></pre>"},{"location":"standards/hcs-2/#update","title":"Update","text":"<p>Modify existing entries, completed by updating the uid or sequence number and updating that record with new metadata.</p> <p>This operation is invalid for non-indexed topics</p> <p>Use the following JSON structure:</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"update\",\n  \"uid\": \"SEQUENCE_NUMBER_OF_REGISTER_MESSAGE_TO_UPDATE\",\n  \"t_id\": \"NEW_TOPIC_ID_TO_REGISTER\",\n  \"metadata\": \"OPTIONAL_METADATA (HIP-412 compliant)\",\n  \"m\": \"OPTIONAL_MEMO\"\n}\n</code></pre> <p>example usage:</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"update\",\n  \"uid\": \"60\",\n  \"t_id\": \"0.0.123456\",\n  \"metadata\": \"hcs://1/0.0.456789\",\n  \"m\": \"update sequence number 60 to a new topic id and metadata\"\n}\n</code></pre>"},{"location":"standards/hcs-2/#migrate","title":"Migrate","text":"<p>This operation is irreversible, and can only exist once within a Topic Id. New messages after a <code>migrate</code> operation are invalid. It is suggested to replicate all data from the previous Topic or create a snapshot with a pointer to the old Topic.</p>"},{"location":"standards/hcs-2/#retrieval","title":"Retrieval","text":"<p>All HRLs pointing to the original Topic, should utilize the new <code>t_id</code> to compute state. Additionally, root Topic Ids with more than 3 <code>migrate</code> operations in any part of the chain would be considered invalid. This safeguard would prevent infinite recursion.</p> <p>Note, this operation is not finalized and should not be used in production.</p> <p>Use the following JSON structure:</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"migrate\",\n  \"t_id\": \"NEW_TOPIC_ID_TO_MIGRATE_TO\",\n  \"metadata\": \"OPTIONAL_METADATA (HIP-412 compliant)\",\n  \"m\": \"OPTIONAL_MEMO\"\n}\n</code></pre> <p>example usage:</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"migrate\",\n  \"t_id\": \"0.0.123456\",\n  \"metadata\": \"hcs://1/0.0.456789\",\n  \"m\": \"All hope is lost. We're moving on.\"\n}\n</code></pre>"},{"location":"standards/hcs-2/#memo-for-indexers-and-browsers","title":"Memo for Indexers and Browsers","text":"<p>A memo system is defined for indexers and browsers to understand the data's state and interpret it accordingly. The memo format follows:</p> <p><code>[protocol_standard]:[indexed]:[ttl]</code></p> Field Description Example Value <code>protocol_standard</code> Protocol used by the registry, <code>hcs-2</code> for this standard. <code>hcs-2</code> <code>indexed</code> enum value of if all messages need pulled down or only the last / newest message <code>0</code> <code>ttl</code> a numeric value, representing the number of seconds which external infrastructure can use to determine how long messages in this registry should be stored in cache <code>60</code> Indexed enum Description <code>0</code> The topic id is indexed, and all messages should be read <code>1</code> The topic id is not indexed, and only the last message should be used to determine state / topic data"},{"location":"standards/hcs-2/#example-memo-format","title":"Example Memo Format","text":"<p><code>hcs-2:0:60</code></p>"},{"location":"standards/hcs-2/#indexed-registry-mechanics-enum-0","title":"Indexed Registry Mechanics [enum: 0]","text":"<p>Uses: Topic ids used for registiers where you need all records to get the data you need to execute logic. Typically good for most registeries.</p> <p>Examples: 1. User registry for profiles of a video game 2. A registry for posts on a social media site for a specific user</p> <ul> <li>Expectation for new records to be continually added.</li> <li>Indexers should gather all files and metadata listed in the registry.</li> <li>Processing state should start from the first message and proceed to the last sequential message number.</li> </ul>"},{"location":"standards/hcs-2/#non-indexed-registry-mechanics-enum-1","title":"Non-Indexed Registry Mechanics [enum: 1]","text":"<p>Uses: Topic ids used for dynamic state of an entity. The latest message being used is the current state of the entity being defined</p> <p>Examples: 1. A description for a product on a ecom site 2. A state of an NFT for a video game</p> <ul> <li>Expectation for new records to be continually added.</li> <li>Indexers should gather <code>only the last message</code> and metadata in that message will determine the protocol and execution.</li> <li>Processing state should start from the first message and proceed to the last sequential message number.</li> </ul>"},{"location":"standards/hcs-2/#ttl-use-cases","title":"TTL Use Cases","text":"<p>External infrastructure, dApps, clients should utilize the TTL as a reference point for how long to cache data, before attempting to fetch new messages from the registry. The default suggested value is 86400 (one day). Certain use cases might opt for lower or higher TTL values. For scalability, it is imperative to pick values that make the most sense.</p>"},{"location":"standards/hcs-2/#use-cases-and-functionalities","title":"Use Cases and Functionalities","text":"<ul> <li>Dynamic metadata enables NFTs and other assets to reflect changes and updates over time.</li> <li>Full version history allows for a complete understanding of an item's evolution.</li> <li>Enhanced file and website management through recursive indexing and state awareness.</li> </ul>"},{"location":"standards/hcs-2/#example-uri-format","title":"Example URI Format","text":"<p>Registry links should follow a consistent format to ensure easy access and interpretation:</p> <p><code>hcs://2/{topic_id}</code></p> <p>This facilitates direct access to specific registry entries and simplifies integration with external systems and applications.</p>"},{"location":"standards/hcs-2/#validation","title":"Validation","text":"<p>Each field within the JSON structure for the <code>register</code>, <code>delete</code>, and <code>update</code> operations must meet specific criteria to be considered valid:</p> <ul> <li><code>p</code> (Protocol): Must be a string matching <code>hcs-2</code>. This validates that the entry adheres to the current standard.</li> <li><code>op</code> (Operation): Must be one of <code>register</code>, <code>delete</code>, or <code>update</code>. This indicates the action being performed. Note, <code>update</code> and <code>delete</code> would not be valid or needed operations for a <code>non-indexed</code> topic.</li> <li><code>t_id</code> (Topic ID): Should match the Hedera account ID format, which is three groups of numbers separated by periods (e.g., <code>0.0.123456</code>).</li> <li><code>uid</code> (Unique Identifier): Must be a valid sequence number or unique identifier relevant to the operation.</li> <li><code>m</code> (Memo): An optional field providing additional context or information. Limited to 500 characters.</li> <li><code>ttl</code>: An optional field providing an override to the TTL in the memo. Typically not required.</li> </ul>"},{"location":"standards/hcs-2/#attributes-validation","title":"Attributes Validation","text":"<p>Specific validation rules for each attribute ensure that users adhere to the format and standards expected within the HCS framework, enhancing interoperability and consistency.</p>"},{"location":"standards/hcs-2/#conclusion","title":"Conclusion","text":"<p>HCS-2 creates a method of connecting data and enabling dynamic state registries</p>"},{"location":"standards/hcs-20/","title":"HCS-20 Standard: Auditable Points Standard on Hedera","text":""},{"location":"standards/hcs-20/#status-published","title":"Status: Published","text":"<ul> <li>HCS-20 Standard: Auditable Points Standard on Hedera<ul> <li>Authors</li> </ul> </li> <li>Solving the Auditable Points Challenge</li> <li>The Role of Hedera<ul> <li>Hedera's Main Features:</li> </ul> </li> <li>Harnessing HCS-20 with the Turtle Moon HCS App</li> <li>Two Operational Modes<ul> <li>Main public topic Id for inscriptions:</li> </ul> </li> <li>Operations and State Calculation<ul> <li>Key Operations</li> <li>Validity of Transactions</li> </ul> </li> <li>Conclusion</li> </ul>"},{"location":"standards/hcs-20/#authors","title":"Authors","text":"<ul> <li>Patches https://twitter.com/TMCC_Patches</li> </ul> <p>HCS-20 is a new proposed standard (created by @TurtelMoonCC &amp; @HGraphPunks) that defines how points can be managed and audited on the Hedera network. It is inspired by the BRC-20 protocol on Ordinals and has extended the functionality to auditable points in addition to introducing inscriptions on Hedera / Hashinals.</p>"},{"location":"standards/hcs-20/#solving-the-auditable-points-challenge","title":"Solving the Auditable Points Challenge","text":"<p>The HCS-20 standard emerges as a solution to a pressing problem in the web2 and web3 world: the need for a transparent, auditable, and versatile control system for points. Its primary benefits include:</p> <ul> <li>Public Audit-ability: Creates audit log for transparency in point transactions.</li> <li>No LP or Value Expectation Issues: Streamlines operations without liquidity, compliance, or value complications. Great for loyalty points, gaming points, etc.</li> <li>Control Flexibility: If in private mode, it offers the creator the power to oversee all point movements.</li> </ul> <p>WARNING THIS IS IN ALPHA The Indexer will be updated periodically and the way transactions are calculated may change as the standard matures. No points are intended to have any value.</p>"},{"location":"standards/hcs-20/#the-role-of-hedera","title":"The Role of Hedera","text":"<p>Hedera stands out as a superb platform for documenting point movements due to its inherent benefits, such as high efficiency, robust security, cheap consistent costs, and a user-friendly ecosystem.</p>"},{"location":"standards/hcs-20/#hederas-main-features","title":"Hedera's Main Features:","text":"<ul> <li>ABFT Security</li> <li>3.5 seconds to finality</li> <li>$0.0001 per inscription on HCS (pegged to USD)</li> <li>Low energy usage</li> <li>10,000 tps</li> </ul>"},{"location":"standards/hcs-20/#harnessing-hcs-20-with-the-turtle-moon-hcs-app","title":"Harnessing HCS-20 with the Turtle Moon HCS App","text":"<p>The Turtle Moon App simplifies the creation and management of HCS-20 points. Here's how you can leverage its features:</p> <ul> <li>Download and Install: Available for Mac, Windows, and Linux. Install here.</li> <li>Create and Interact: Easily initiate a new topic, add wallet and topic ID details, and create JSON for HCS-20 points.</li> <li>Submit and Read: Deploy your points and track point balances through topic ID indexing.</li> </ul> <p>This codebase is in ALPHA, meaning there are a lot of bugs that are still needing to be fixed and enhancements to be integrated. USE AT YOUR OWN RISK. This software is provided as is and Turtle Moon is not responsible for any issues using the software.</p>"},{"location":"standards/hcs-20/#two-operational-modes","title":"Two Operational Modes","text":"<ul> <li>Private Mode with Submit Key: This mode offers control over data posted to a topic, ideal for most use cases where authorized parties require exclusive write access.</li> <li>Public Mode without Submit Key: Allows open, public transactions, suitable for decentralized applications where transparency is key, and open mints are wanted.</li> </ul>"},{"location":"standards/hcs-20/#main-public-topic-id-for-inscriptions","title":"Main public topic Id for inscriptions:","text":"<ul> <li><code>0.0.4350190</code></li> </ul>"},{"location":"standards/hcs-20/#operations-and-state-calculation","title":"Operations and State Calculation","text":"<p>HCS-20 standardizes operations like deploying, minting, burning, and transferring points. The state of these points is determined by aggregating these operations on the HCS topic IDs.</p>"},{"location":"standards/hcs-20/#key-operations","title":"Key Operations","text":"<ul> <li>Deploy Point Contract: Initialize a new asset.</li> <li>Mint Point: Generate and assign new points.</li> <li>Burn Point: Remove points from circulation.</li> <li>Transfer Point: Facilitate point movement between accounts.</li> </ul>"},{"location":"standards/hcs-20/#validity-of-transactions","title":"Validity of Transactions","text":"<p>Transactions are valid based on several criteria, including the balance availability at the time of inscription and the consensus timestamp order. For public mode operations, the payer account ID must match the account from which points are removed.</p>"},{"location":"standards/hcs-20/#conclusion","title":"Conclusion","text":"<p>The HCS-20 standard, complemented by the Turtle Moon App, offers a robust framework for creating an auditable point systems on Hedera Consensus Service Topic IDs.</p>"},{"location":"standards/hcs-5/","title":"HCS-5 Standard: Tokenized HCS-1 Files, Hashinals","text":""},{"location":"standards/hcs-5/#status-published","title":"Status: Published","text":""},{"location":"standards/hcs-5/#table-of-contents","title":"Table of Contents","text":"<ul> <li>HCS-5 Standard: Tokenized HCS-1 Files, Hashinals<ul> <li>Status: Published</li> <li>Table of Contents</li> </ul> </li> <li>Authors</li> <li>Abstract</li> <li>Motivation</li> <li>Specification<ul> <li>Metadata</li> <li>Metadata Example</li> <li>Inscription Numbers</li> <li>Validation</li> <li>Inscription Registry</li> <li>Submitting to the Registry</li> <li>Registry fields</li> <li>Register Inscriptions</li> <li>Reset Registry</li> <li>User Process for inscribing Hashinals</li> <li>Conclusion</li> </ul> </li> </ul>"},{"location":"standards/hcs-5/#authors","title":"Authors","text":"<ul> <li>Kantorcodes https://twitter.com/kantorcodes</li> <li>Patches https://twitter.com/TMCC_Patches</li> </ul>"},{"location":"standards/hcs-5/#abstract","title":"Abstract","text":"<p>This specification provides a standard way to \"inscribe\" Hashinals utilizing the Hedera Consensus and Hedera Token Services. Hashinals borrow many ideas from Ordinal theory on Bitcoin, and apply them in a more efficient, and scalable way for the Hedera Hashgraph.</p>"},{"location":"standards/hcs-5/#motivation","title":"Motivation","text":"<p>Token creators and downstream consumers would like for the whole of NFT metadata to be written directly to the Hashgraph, as opposed to off-chain mediums like IPFS, Arweave, etc. Metadata stored in this manner would reduce coupling to those off-chain stores, and should improve future compatibility with services like the Smart Contract Service, and Hedera Consensus Service. In this manner, the entirety of the NFT is truly \"on-chain\".</p>"},{"location":"standards/hcs-5/#specification","title":"Specification","text":"<p>Hashinals are minted with the Hedera Token Service (HTS) and securely recorded on the Hedera Consensus Service using a HCS-2 guarded registry. Unlike typical NFTs on Hedera, metadata is stored as valid HCS-1 files.</p>"},{"location":"standards/hcs-5/#metadata","title":"Metadata","text":"<p>Hashinals are discovered through the <code>metadata</code> field on every new Serial Number minted onto tokens via the Hedera Token Service. The metadata field must use a valid HRL (Hedera Resource Locater) to reference the Topic ID in which an HCS-1 file is inscribed onto.</p> <p>The format of the field is as follows: <code>hcs://{hcsStandard}/{topicId}</code></p> <p><code>hcsStandard</code> tells you which HCS standard to use when referencing the Topic ID. At this time, this field will always be <code>1</code>.</p> <p><code>topicId</code> is a valid HCS-1 Topic ID in which data for this NFT written to. Please note that while other popular metadata standards will work, a JSON file following the HIP-412 is recommended for your Hashinals to work properly in the Hedera ecosystem. </p> <p>Bare Minimal example of metadata</p> <pre><code> {\n   \"name\": \"My NFT\",\n   \"creator\": \"Creator Name\",\n   \"description\": \"My description\",\n   \"image\": \"hcs://1/0.0.12345\",\n   \"type\": \"image/png\",\n   \"attributes\": [],\n }\n</code></pre>"},{"location":"standards/hcs-5/#metadata-example","title":"Metadata Example","text":"<p>The following is a valid example of the metadata string saved onto the serial number of an NFT on HTS: <code>hcs://1/0.0.3601682</code></p>"},{"location":"standards/hcs-5/#inscription-numbers","title":"Inscription Numbers","text":"<p>Like Serial Numbers on individual Token IDs, Inscription Numbers are essentially an HCS Registry that describe the order in which Hashinals are \"inscribed\". The key facets that are followed for determining these numbers are that:</p> <ul> <li>\"First is first\" and determined entirely by the Hashgraph.</li> <li>The process is easy to understand and replicate.</li> </ul> <p>Inscription numbers start from <code>1</code>.</p> <p>Order is determined by sorting the <code>consensus_timestamp</code> on TokenMintTransactions which correctly follow validation requirements. Invalid mints will not be assigned inscription numbers.</p>"},{"location":"standards/hcs-5/#validation","title":"Validation","text":"<p>Hashinals must:</p> <ul> <li>Use a valid HCS-1 file. Tokens minted with invalid HCS-1 files will be considered invalid and ignored.</li> <li>Follow the format for metadata specified in Metadata</li> <li>Be minted after 11:07:25.6556 AM Mar 5, 2024, EST (1709654845.655672003). Tokens minted with a valid HRL before this date will not be assigned an inscription number.</li> </ul>"},{"location":"standards/hcs-5/#inscription-registry","title":"Inscription Registry","text":"<p>All valid Hashinals, will be registered in a private Topic ID managed by the HCS Council for the convenience of the ecosystem. The registry serves a dual purpose of recording inscription numbers and providing a database for applications to explore the Hashinals ecosystem.</p> <p>The process of maintaining a registry can be replicated outside of the Council, but must follow the specification to be valid.</p>"},{"location":"standards/hcs-5/#submitting-to-the-registry","title":"Submitting to the Registry","text":"<p>Messages must be submitted as valid JSON and use the Registry fields as described below.</p>"},{"location":"standards/hcs-5/#registry-fields","title":"Registry fields","text":"<p>The sum of all fields should not exceed 1024KB, or the registration will be invalid. </p> Field Description Example Value <code>p</code> The protocol used by the registry. Should always be <code>hcs-5</code> unless superseded. <code>hcs-5</code> <code>op</code> The operation being executed. <code>register</code> or <code>reset</code> <code>t_id</code> The topic where the valid HCS-1 file or new registry is located. <code>0.0.3541181</code> <code>ht_id</code> The Token ID for the registered inscription <code>0.0.11111</code> <code>sn</code> The serial number of the registered inscription <code>1</code> <code>m</code> Any optional metadata the indexer might want included <code>Inscribed by 0.0.1234145 on TurtleMoon</code> <code>type</code> Any valid mimeType of the inscription. <code>image/png</code>"},{"location":"standards/hcs-5/#register-inscriptions","title":"Register Inscriptions","text":"<p>Valid register messages will have the following format on the Hashinals Topic ID. Registration is merely the process of indexing inscription numbers for valid serials on Token IDs.</p> <pre><code>{\n  \"p\": \"hcs-5\",\n  \"op\": \"register\",\n  \"t_id\": \"0.0.3541181\",\n  \"ht_id\": \"0.0.11111\",\n  \"sn\": 1,\n  \"m\": \"Inscribed by 0.0.1234145 on TurtleMoon\"\n  \u201ctype\u201d: \u201cimage/png\u201d // or any other valid mime type\n}\n</code></pre>"},{"location":"standards/hcs-5/#reset-registry","title":"Reset Registry","text":"<p>In rare events, it could be required to \"Reset\" the registry. This is a fallback mechanism that should be exercised with extreme caution. On reset, a new Topic ID is provided which will serve as the defacto replacement of the Hashinals Registry.</p> <pre><code>{\n  \"p\": \"hcs-5\",\n  \"op\": \"reset\",\n  \"t_id\": \"0.0.999999\",\n  \"m\": \"The world is on fire. We had to move.\"\n}\n</code></pre>"},{"location":"standards/hcs-5/#user-process-for-inscribing-hashinals","title":"User Process for inscribing Hashinals","text":""},{"location":"standards/hcs-5/#conclusion","title":"Conclusion","text":"<p>The HCS-5 standard introduces a robust and on-chain method for inscribing NFT metadata directly onto the Hedera Hashgraph, named Hashinals. By integrating the Hedera Consensus Service (HCS) with the Hedera Token Service (HTS), it creates a decentralized and verifiable way to manage NFT metadata, ensuring the longevity and integrity of digital assets in the Hedera ecosystem.</p> <p>Adopting this standard addresses the drawbacks associated with relying on external storage systems by keeping the entirety of NFT data on-chain. This enhances the trust and value of NFTs by ensuring their metadata is immutable and perpetually accessible.</p> <p>The detailed specification provided here, from metadata structure to the inscription registry process, gives creators and users clear guidelines and tools for minting and managing Hashinals.</p>"},{"location":"standards/hcs-6/","title":"HCS-6 Standard: Dynamic Hashinals","text":""},{"location":"standards/hcs-6/#status-published","title":"Status: Published","text":""},{"location":"standards/hcs-6/#table-of-contents","title":"Table of Contents","text":"<ul> <li>HCS-6 Standard: Dynamic Hashinals<ul> <li>Status: Published</li> <li>Table of Contents</li> </ul> </li> <li>Authors<ul> <li>Additional Authors</li> </ul> </li> <li>Abstract</li> <li>Motivation</li> <li>Specification<ul> <li>Creating an HCS-2 Topic ID</li> <li>Metadata</li> <li>Submitting Messages</li> <li>Validation</li> <li>Limitations</li> <li>Conclusion</li> </ul> </li> </ul>"},{"location":"standards/hcs-6/#authors","title":"Authors","text":"<ul> <li>Kantorcodes https://twitter.com/kantorcodes</li> </ul>"},{"location":"standards/hcs-6/#additional-authors","title":"Additional Authors","text":"<ul> <li>Patches https://twitter.com/tmcc_patches</li> </ul>"},{"location":"standards/hcs-6/#abstract","title":"Abstract","text":"<p>This standard introduces a way to inscribe and tokenize Hashinals whose <code>metadata</code> can be updated at a whim by utilizing an HCS-2, non-indexed Topic ID.</p>"},{"location":"standards/hcs-6/#motivation","title":"Motivation","text":"<p>Creators of NFT Collections, sometimes desire the ability to change the metadata of an NFT, for example in cases of:</p> <ul> <li>correcting mistakes in metadata during initial inscription</li> <li>providing holders with new variations of artwork / attributes over time</li> <li>updating numerical stats from leveling up or down during a game</li> </ul> <p>The list above is non-exhaustive and can be expanded to many use cases.</p>"},{"location":"standards/hcs-6/#specification","title":"Specification","text":"<p>Creating a Dynamic Hashinal involves four steps.</p> <ol> <li>Creating a valid, <code>non-indexed</code> HCS-2 Topic ID</li> <li>Minting a new Serial Number on a Token ID following the Metadata format</li> <li>Creating a valid HCS-1 Topic ID</li> <li>Submitting a valid message to the HCS-2 Topic ID with the HCS-1 file.</li> </ol> <p>Steps 2-4 can be repeated every time the NFT will be updated.</p>"},{"location":"standards/hcs-6/#creating-an-hcs-2-topic-id","title":"Creating an HCS-2 Topic ID","text":"<p>The <code>memo</code> field for Dynamic Hashinals must follow this format to be valid.</p> <p><code>`hcs-2:non-indexed:{ttl}</code></p> <p>The only variable element in the memo would be the <code>ttl</code> field. We suggest a longer <code>ttl</code> as this is the time in seconds that gateways and clients will store the previous version of your <code>metadata</code> in their cache. In the future, gateways and clients may decide to prioritize Topics with longer <code>metadata</code> by imposing fees, introducing rate limits, etc. The minimum <code>ttl</code> must be <code>3600</code> (1 hour) to be valid, and the suggested minimum would be <code>86400</code> (1 day)</p>"},{"location":"standards/hcs-6/#metadata","title":"Metadata","text":"<p>Dynamic Hashinals follow all of the same rules described in HCS-5, with one main exception being that they will utilize the <code>HCS-2</code> hcsStandard instead of <code>HCS-1</code>. The resulting HRL minted onto a serial number includes the protocol number <code>6</code></p> <p>The format of the <code>metadata</code> on a dynamic Hashinal is as follows:</p> <p><code>hcs://6/{topicId}</code></p> <p><code>topicId</code> is a valid HCS-2 Registry Topic ID in which data for this NFT will be or is written to.</p> <p>The purpose of including the file standard in the HRL is to enable client applications to make logical decisions based on its existence. For example:</p> <ul> <li>a client might decide to use a different gateway to load immutable (HCS-5) versus Dynamic (HCS-6) Hashinals without needing to load the <code>memo</code> for each topic.</li> <li>analytics and indexer applications can search for all NFTs that include a HCS-2 HRL.</li> </ul>"},{"location":"standards/hcs-6/#submitting-messages","title":"Submitting Messages","text":"<p>In a <code>non-indexed</code> Topic ID, the most recent <code>register</code> operation is the current pointer for your metadata. You can submit a new message to update the <code>metadata</code> within the <code>ttl</code> specified on the <code>memo</code> of your HCS-2 Topic ID.</p> <p>Each message follows this format.</p> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"register\",\n  // the HCS-1 Topic ID\n  \"t_id\": \"0.0.12345\",\n  \"m\": \"Season 2 update for the Hashinal Hounds\",\n}\n</code></pre> <p>Clients, dApps, gateways, etc, will read the most recent sequence number's <code>t_id</code> to locate the current <code>metadata</code> of this Dynamic Hashinal</p>"},{"location":"standards/hcs-6/#validation","title":"Validation","text":"<p>Dynamic Hashinals are only valid when</p> <ul> <li>Their HCS-2 Topic ID is <code>non-indexed</code></li> <li>The latest message in the HCS-2 Topic ID has a valid HCS-1 Topic ID for the <code>t_id</code> field</li> <li>They specify a <code>ttl</code> that is at least <code>3600</code> (1 day)</li> <li>It is created after <code>1713886229389232400</code> nanosecond timestamp</li> </ul>"},{"location":"standards/hcs-6/#limitations","title":"Limitations","text":"<p>While HCS-6 is built on HCS-2, it includes some important limitations to improve UX.</p> <ol> <li>Inscribed messages cannot utilize recursion in submitted messages to the registry. For example, the following would be invalid</li> </ol> <pre><code>{\n  \"p\": \"hcs-2\",\n  \"op\": \"register\",\n  // an HCS-2 Topic ID\n  \"t_id\": \"0.0.12345\",\n  \"m\": \"Pointing metadata to another registry.\",\n}\n</code></pre> <ol> <li>HCS-6 will always use a <code>non-indexed</code> Topic ID. <code>update</code> and <code>delete</code> operations will not be valid.</li> </ol>"},{"location":"standards/hcs-6/#conclusion","title":"Conclusion","text":"<p>HCS-6 clearly defines how to inscribe Dynamic Hashinals on the Hedera Hashgraph utilizing the Consensus Service. Note, to avoid all doubt, operations and functionality not written within this standard are invalid and should not be assumed.</p>"}]}