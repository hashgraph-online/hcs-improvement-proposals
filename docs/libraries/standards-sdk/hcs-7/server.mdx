---
title: Node — Registry + Bridges
description: Use `HCS7Client`, `EVMBridge`, and `WasmBridge` from server environments.
sidebar_position: 2
---

import LanguageTabs from '@site/src/components/LanguageTabs';
import TabItem from '@theme/TabItem';

## 1. Instantiate the Node Client

<LanguageTabs>
<TabItem value="typescript">

```ts
import { HCS7Client, HCS7ConfigType } from '@hashgraphonline/standards-sdk';

const hcs7 = new HCS7Client({
  network: 'testnet',
  operatorId: process.env.HEDERA_ACCOUNT_ID!,
  operatorKey: process.env.HEDERA_PRIVATE_KEY!,
});
```

</TabItem>
<TabItem value="go">

```go
import (
	"os"
	"github.com/hashgraph-online/standards-sdk-go/pkg/hcs7"
)

client, err := hcs7.NewClient(hcs7.ClientConfig{
	Network:            "testnet",
	OperatorAccountID:  os.Getenv("HEDERA_ACCOUNT_ID"),
	OperatorPrivateKey: os.Getenv("HEDERA_PRIVATE_KEY"),
})
```

</TabItem>
</LanguageTabs>

The client wraps all topic/transaction plumbing: memo generation (`hcs-7:indexed:{ttl}`), signing, and receipt handling. Call `hcs7.close()` when you finish.

## 2. Create a Registry Topic

<LanguageTabs>
<TabItem value="typescript">

```ts
const registry = await hcs7.createRegistry({ ttl: 86_400, submitKey: true });
if (!registry.success || !registry.topicId) throw new Error(registry.error);

console.log('Registry Topic:', registry.topicId);
```

</TabItem>
<TabItem value="go">

```go
registry, err := client.CreateRegistry(ctx, hcs7.CreateRegistryOptions{
	TTL:                 86400,
	UseOperatorAsSubmit: true,
})
if err != nil || !registry.Success {
	panic("failed to create registry")
}

fmt.Println("Registry Topic:", registry.TopicID)
```

</TabItem>
</LanguageTabs>

- `ttl` must be ≥ 3600 seconds.
- `submitKey: true` reuses the operator key as the topic submit key. Pass a `PrivateKey` or `string` to use a dedicated key.

## 3. Register EVM + WASM Configs

<LanguageTabs>
<TabItem value="typescript">

```ts
await hcs7.registerConfig({
  registryTopicId: registry.topicId,
  memo: 'LaunchPage minted',
  config: {
    type: HCS7ConfigType.EVM,
    contractAddress: '0x1d67aaf7f7e8d806bbeba24c4dea24808e1158b8',
    abi: {
      name: 'minted',
      inputs: [],
      outputs: [{ name: '', type: 'uint64' }],
      stateMutability: 'view',
      type: 'function',
    },
  },
});

await hcs7.registerConfig({
  registryTopicId: registry.topicId,
  memo: 'mint router',
  config: {
    type: HCS7ConfigType.WASM,
    wasmTopicId: '0.0.5269810',
    inputType: {
      stateData: {
        minted: 'number',
        tokensRemaining: 'number',
      },
    },
    outputType: {
      type: 'string',
      format: 'topic-id',
    },
  },
});
```

</TabItem>
<TabItem value="go">

```go
_, err = client.RegisterConfig(ctx, hcs7.RegisterConfigOptions{
	RegistryTopicID: registry.TopicID,
	Memo:            "LaunchPage minted",
	Type:            hcs7.ConfigTypeEVM,
	EVM: &hcs7.EvmConfigPayload{
		ContractAddress: "0x1d67aaf7f7e8d806bbeba24c4dea24808e1158b8",
		Abi: hcs7.AbiDefinition{
			Name: "minted",
			Inputs: []hcs7.AbiIO{},
			Outputs: []hcs7.AbiIO{{Name: "", Type: "uint64"}},
			StateMutability: "view",
			Type: "function",
		},
	},
})

_, err = client.RegisterConfig(ctx, hcs7.RegisterConfigOptions{
	RegistryTopicID: registry.TopicID,
	Memo:            "mint router",
	Type:            hcs7.ConfigTypeWASM,
	WASM: &hcs7.WasmConfigPayload{
		WasmTopicID: "0.0.5269810",
		InputType: map[string]any{
			"stateData": map[string]string{
				"minted": "number",
				"tokensRemaining": "number",
			},
		},
		OutputType: map[string]any{
			"type": "string",
			"format": "topic-id",
		},
	},
})
```

</TabItem>
</LanguageTabs>

Each registration writes a `register-config` message into the same HCS‑7 topic the toolkit polls.

## 4. Register Metadata Targets

<LanguageTabs>
<TabItem value="typescript">

```ts
await hcs7.registerMetadata({
  registryTopicId: registry.topicId,
  metadataTopicId: '0.0.3717738',
  weight: 1,
  tags: ['odd'],
  memo: 'odd artwork',
});

await hcs7.registerMetadata({
  registryTopicId: registry.topicId,
  metadataTopicId: '0.0.3717746',
  weight: 1,
  tags: ['even'],
  memo: 'even artwork',
});
```

</TabItem>
<TabItem value="go">

```go
_, err = client.RegisterMetadata(ctx, hcs7.RegisterMetadataOptions{
	RegistryTopicID: registry.TopicID,
	MetadataTopicID: "0.0.3717738",
	Weight:          1,
	Tags:            []string{"odd"},
	Memo:            "odd artwork",
})

_, err = client.RegisterMetadata(ctx, hcs7.RegisterMetadataOptions{
	RegistryTopicID: registry.TopicID,
	MetadataTopicID: "0.0.3717746",
	Weight:          1,
	Tags:            []string{"even"},
	Memo:            "even artwork",
})
```

</TabItem>
</LanguageTabs>

## 5. Query the Registry

<LanguageTabs>
<TabItem value="typescript">

```ts
const topic = await hcs7.getRegistry(registry.topicId, { limit: 50 });
topic.entries.forEach(entry => {
  console.log(entry.sequenceNumber, entry.message.op, entry.message.m);
});
```

</TabItem>
<TabItem value="go">

```go
topic, err := client.GetRegistry(ctx, registry.TopicID, shared.QueryOptions{Limit: 50})
if err == nil {
	for _, entry := range topic.Entries {
		fmt.Println(entry.SequenceNumber, entry.Message.Op, entry.Message.M)
	}
}
```

</TabItem>
</LanguageTabs>

`getRegistry` reads the Mirror Node, validates each message against the HCS‑7 schema, and returns typed entries.

## 6. Use the Bridges for State + Routing

> **Note**: The EVM and WASM Bridges are currently available in the TypeScript SDK.

### EVMBridge

<LanguageTabs>
<TabItem value="typescript">

```ts
import { EVMBridge } from '@hashgraphonline/standards-sdk';

const evm = new EVMBridge('testnet');
const { result } = await evm.executeCommand({
  c: {
    contractAddress: '0x1d67aaf7f7e8d806bbeba24c4dea24808e1158b8',
    abi: {
      name: 'minted',
      inputs: [],
      outputs: [{ name: '', type: 'uint64' }],
      stateMutability: 'view',
      type: 'function',
    },
  },
});

console.log('Minted so far:', result.values?.[0]);
```

</TabItem>
<TabItem value="go">

```go
// Note: EVMBridge is available in the TypeScript SDK. 
// See the TypeScript tab for examples.
```

</TabItem>
</LanguageTabs>

Swap in `RedisCache` if you need a shared cache across processes:

<LanguageTabs>
<TabItem value="typescript">

```ts
import { RedisCache } from '@hashgraphonline/standards-sdk';
const evm = new EVMBridge('testnet', undefined, new RedisCache({ host: '127.0.0.1' }));
```

</TabItem>
<TabItem value="go">

```go
// Note: EVMBridge is available in the TypeScript SDK.
```

</TabItem>
</LanguageTabs>

### WasmBridge

<LanguageTabs>
<TabItem value="typescript">

```ts
import { WasmBridge } from '@hashgraphonline/standards-sdk';

const wasm = new WasmBridge();
const wasmBytes = await fetch('https://kiloscribe.com/api/inscription-cdn/0.0.5269810?network=testnet').then(r => r.arrayBuffer());
await wasm.initWasm(wasmBytes);

const messages = await hcs7.getRegistry(registry.topicId, { limit: 100 });
const stateData = {
  minted: '42',
  tokensRemaining: '58',
};

const topicId = wasm.executeWasm(stateData, messages.entries.map(e => e.message));
console.log('Selected metadata topic:', topicId);
```

</TabItem>
<TabItem value="go">

```go
// Note: WasmBridge is available in the TypeScript SDK.
// See the TypeScript tab for examples.
```

</TabItem>
</LanguageTabs>

## 7. Low-Level Transactions

When you need to integrate with other toolchains (e.g., schedule a submit in HCS‑10 or build transactions inside the Agent Kit), use the helpers in [`src/hcs-7/tx.ts`](./tx.mdx).

- `buildHcs7CreateRegistryTx`
- `buildHcs7SubmitMessageTx`
- `buildHcs7EvmMessageTx`
- `buildHcs7WasmMessageTx`

Each helper serializes the payload (`p: 'hcs-7'`, `op`, etc.) so you only need to sign/send it with the Hedera SDK or another orchestration tool.

---

## 8. Fetching Metadata / WASM from KiloScribe

Any topic you inscribe with the Standards SDK (metadata or WASM) is mirrored to the CDN. Use it when rendering hashinals or downloading routers server-side:

<LanguageTabs>
<TabItem value="typescript">

```ts
const topicId = '0.0.3717746';
const res = await fetch(
  `https://kiloscribe.com/api/inscription-cdn/${topicId}?network=testnet`,
  { headers: { Accept: 'application/json' } },
);
const metadata = await res.json();
```

</TabItem>
<TabItem value="go">

```go
topicID := "0.0.3717746"
url := fmt.Sprintf("https://kiloscribe.com/api/inscription-cdn/%s?network=testnet", topicID)

req, _ := http.NewRequest("GET", url, nil)
req.Header.Set("Accept", "application/json")

res, err := http.DefaultClient.Do(req)
if err == nil {
	defer res.Body.Close()
	var metadata map[string]any
	json.NewDecoder(res.Body).Decode(&metadata)
}
```

</TabItem>
</LanguageTabs>

For WASM binaries:

<LanguageTabs>
<TabItem value="typescript">

```ts
const wasmTopicId = '0.0.5269810';
const wasmBytes = await fetch(
  `https://kiloscribe.com/api/inscription-cdn/${wasmTopicId}?network=testnet`,
  { headers: { Accept: 'application/wasm' } },
).then(r => r.arrayBuffer());
```

</TabItem>
<TabItem value="go">

```go
wasmTopicID := "0.0.5269810"
url := fmt.Sprintf("https://kiloscribe.com/api/inscription-cdn/%s?network=testnet", wasmTopicID)

req, _ := http.NewRequest("GET", url, nil)
req.Header.Set("Accept", "application/wasm")

res, err := http.DefaultClient.Do(req)
if err == nil {
	defer res.Body.Close()
	wasmBytes, _ := io.ReadAll(res.Body)
}
```

</TabItem>
</LanguageTabs>

You can still pull messages directly from HCS topics if you prefer, but the CDN saves repeated decoding.
